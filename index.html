<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cultural Coinage Generator</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#071022; color:#E6EEF9; }
    .scrolling-panel::-webkit-scrollbar{ width:10px } .scrolling-panel::-webkit-scrollbar-thumb{ background:#213449; border-radius:8px }
    .fade { animation: fade 220ms ease-out; } @keyframes fade{ from{opacity:0; transform:translateY(6px)} to{opacity:1; transform:none} }
    .small-muted { color:#9fb0c7; font-size:13px }
    .chip { padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); cursor:pointer; user-select:none }
    .chip.active { background: linear-gradient(90deg,#294e86,#2b6fb3); color:white; box-shadow:0 6px 18px rgba(41,78,134,0.14) }
    .spinner{ border:4px solid rgba(255,255,255,0.06); border-top-color:#60a5fa; border-radius:999px; width:36px; height:36px; animation:spin 0.9s linear infinite } @keyframes spin{ to{transform:rotate(360deg)} }
    a.debug { color:#8fb6ff; text-decoration:underline }
  </style>
</head>
<body>
  <div id="app" class="min-h-screen p-6"></div>

  <script>
/**
 * Cultural Coinage Generator — Full-Featured Version
 * Philosophy: Blend linguistic roots (e.g., Turkish, Nordic) with themes (cosmic, nature)
 * to create evocative, pronounceable, and culturally respectful names.
 */

(function () {
  // --- CONFIG ---
  const API_BASE_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent";
  const DEFAULT_COUNT = 6;
  const LANG_OPTIONS = ["Turkish","Nordic","Latin","Celtic","Slavic","Japanese","Greek","Sanskrit","Arabic"];
  const THEME_OPTIONS = ["Nature","Cosmic","Balance","Strength","Water","Light","Shadow","Music", "Fire", "Mountain", "Ocean", "Sky", "Forest", "Mythic"];
  const STYLE_OPTIONS = ["Lyrical & Melodic","Archaic & Mythic","Minimalist & Modern","Heroic & Resonant", "Elegant & Refined", "Grounded & Earthy", "Mystical & Ethereal"];
  const SYSTEM_BLACKLIST = ["tuna","ilay","baran","nur","solren","kuzel","anal"];

  // --- State ---
  const appState = {
    apiKey: "",
    isLoading: false,
    error: null,
    results: [],
    likedNames: [],
    selectedLanguages: ["Celtic", "Sanskrit"],
    selectedThemes: ["Light","Balance"],
    selectedStyle: "Lyrical & Melodic",
    surname: "",
    siblingNames: "",
    firstNameForMiddle: "",
    userLanguages: [],
  };
  
  // --- UI Element Cache ---
  const ui = {
      root: document.getElementById('app'),
      controls: {},
      results: {}
  };

  // --- Helpers ---
  const el = (tag, cls='') => { const d = document.createElement(tag); if (cls) d.className = cls; return d; };
  
  function saveState() {
    try {
        const stateToSave = {
            apiKey: appState.apiKey,
            selectedLanguages: appState.selectedLanguages,
            selectedThemes: appState.selectedThemes,
            selectedStyle: appState.selectedStyle,
            likedNames: appState.likedNames,
            userLanguages: appState.userLanguages,
            surname: appState.surname,
            siblingNames: appState.siblingNames,
            firstNameForMiddle: appState.firstNameForMiddle,
        };
        localStorage.setItem('culturalCoinageState', JSON.stringify(stateToSave));
    } catch (e) { console.warn("Could not save state to localStorage:", e); }
  }

  function loadState() {
      try {
        const saved = localStorage.getItem('culturalCoinageState');
        if (saved) {
            const parsed = JSON.parse(saved);
            Object.assign(appState, { ...parsed, likedNames: parsed.likedNames || [], userLanguages: parsed.userLanguages || [] });
        }
      } catch (e) { console.warn("Could not load state from localStorage:", e); }
  }

  function parseApiResponse(text) {
    if (!text) return [];

    let cleanedText = text.replace(/```[\s\S]*?```/g, '');
    const firstBracket = cleanedText.search(/[\[\{]/);
    if (firstBracket > 0) cleanedText = cleanedText.slice(firstBracket);
    const lastBracket = Math.max(cleanedText.lastIndexOf(']'), cleanedText.lastIndexOf('}'));
    if (lastBracket !== -1) cleanedText = cleanedText.slice(0, lastBracket + 1);
    cleanedText = cleanedText.trim();

    if (!cleanedText) return [];

    try {
        const parsed = JSON.parse(cleanedText);
        if (Array.isArray(parsed)) return parsed;
    } catch (e) {
        console.warn("JSON parsing failed, falling back to regex extraction.", e);
    }

    const results = [];
    const entries = text.split(/"name"\s*:/).slice(1);
    for (const entry of entries) {
        const nameMatch = entry.match(/^\s*"([^"]+)"/);
        const meaningMatch = entry.match(/"meaning"\s*:\s*"([^"]+)"/);
        const rootsMatch = entry.match(/"roots"\s*:\s*"([^"]*)"/);
        if (nameMatch?.[1]) {
            results.push({ name: nameMatch[1].trim(), meaning: meaningMatch?.[1].trim() || "", roots: rootsMatch?.[1].trim() || "" });
        }
    }
    return results;
  }

  function scoreName(obj) {
    let s = 0;
    if (!obj || !obj.name) return 0;
    const low = obj.name.toLowerCase();
    if (SYSTEM_BLACKLIST.some(b => low.includes(b))) return -10;
    if (obj.name.length >= 4 && obj.name.length <= 10) s += 2;
    const syl = (obj.name.toLowerCase().match(/[aeiouy]{1,2}/g) || []).length;
    if (syl >= 2 && syl <= 3) s += 2;
    if (obj.meaning?.length > 6) s += 1;
    if (obj.roots?.length > 1) s += 1;
    return s;
  }

  function filterAndScore(rawArray) {
    if (!rawArray?.length) return [];
    return rawArray
        .map(it => ({ name: (it.name || "").toString().trim(), meaning: (it.meaning || "").toString().trim(), roots: (it.roots || "").toString().trim() }))
        .filter(candidate => candidate.name)
        .map(candidate => ({ ...candidate, score: scoreName(candidate) }))
        .filter(candidate => candidate.score > 0)
        .sort((a,b) => b.score - a.score);
  }

  // --- UI Update Functions ---
  function updateResultsPanel() {
      ui.results.panel.innerHTML = '';
      if (appState.isLoading) {
          ui.results.panel.innerHTML = '<div class="flex items-center justify-center py-8"><div class="spinner"></div></div>';
      } else if (appState.error) {
          ui.results.panel.innerHTML = `<div class="bg-[#2b1a1a] border border-[#5b2626] rounded p-4"><div class="text-red-300 font-semibold">Error</div><div class="small-muted mt-2">${escapeHtml(appState.error)}</div></div>`;
      } else if (!appState.results.length) {
          ui.results.panel.innerHTML = '<div class="flex-1 flex items-center justify-center small-muted h-full">No names yet — click Generate.</div>';
      } else {
          const grid = el('div','grid grid-cols-1 sm:grid-cols-2 gap-4');
          appState.results.forEach(item => grid.append(createNameCard(item)));
          ui.results.panel.append(grid);
      }
  }
  
  function updateControls() {
    updateChipSelector(ui.controls.languageChips, [...new Set([...LANG_OPTIONS, ...appState.userLanguages])]);
    updateChipSelector(ui.controls.themeChips, THEME_OPTIONS);
    updateLikedNamesSection();
    ui.controls.generateButton.textContent = appState.likedNames.length > 0 ? 'Riff on Liked' : 'Generate Names';
  }

  function updateChipSelector(container, options) {
      container.innerHTML = '';
      const stateKey = container.dataset.stateKey;
      options.forEach(opt => {
          const c = el('button', 'chip');
          c.textContent = opt;
          c.dataset.option = opt;
          if (appState[stateKey].includes(opt)) c.classList.add('active');
          container.append(c);
      });
  }
  
  function updateLikedNamesSection() {
      ui.controls.likedNamesContainer.innerHTML = '';
      if (appState.likedNames.length > 0) {
        const label = el('label', 'text-sm font-medium');
        label.textContent = 'Liked Names (Inspiration)';
        const wrap = el('div', 'flex flex-wrap gap-2 mt-1');
        appState.likedNames.forEach(nameObj => {
            const chip = el('div', 'chip active flex items-center gap-2');
            const nameSpan = el('span');
            nameSpan.textContent = nameObj.name;
            const removeBtn = el('button', 'font-mono text-xs opacity-70');
            removeBtn.textContent = 'x';
            removeBtn.dataset.action = 'remove-liked';
            removeBtn.dataset.name = nameObj.name;
            chip.append(nameSpan, removeBtn);
            wrap.append(chip);
        });
        ui.controls.likedNamesContainer.append(label, wrap);
      }
  }

  // --- UI Creation ---
  function createNameCard(item) {
      const isLiked = appState.likedNames.some(n => n.name === item.name);
      const card = el('div','bg-[#081426] border border-[#123047] rounded p-4 flex flex-col gap-2 fade');
      
      const header = el('div', 'flex items-start justify-between gap-2');
      const nameEl = el('div', 'text-xl font-semibold'); nameEl.textContent = item.name;
      const scoreEl = el('div', 'text-xs px-2 py-1 rounded bg-[#0f2040] small-muted'); scoreEl.textContent = `score: ${item.score}`;
      header.append(nameEl, scoreEl);

      const meaningEl = el('div', 'italic small-muted'); meaningEl.textContent = item.meaning || '—';
      const rootsEl = el('div', 'text-xs mt-auto small-muted');
      const rootsLabel = el('strong'); rootsLabel.textContent = 'Roots: ';
      rootsEl.append(rootsLabel, document.createTextNode(item.roots || '—'));
      
      const actions = el('div', 'flex gap-2 mt-2');
      const copyBtn = el('button', 'chip'); copyBtn.textContent = 'Copy'; copyBtn.dataset.action = 'copy-name'; copyBtn.dataset.name = item.name;
      const likeBtn = el('button', `chip ${isLiked ? 'active' : ''}`); likeBtn.innerHTML = `&hearts; Like`; likeBtn.dataset.action = 'like-name'; likeBtn.dataset.name = item.name;
      
      actions.append(copyBtn, likeBtn);
      card.append(header, meaningEl, rootsEl, actions);
      return card;
  }
  
  function createContextInput(placeholder, stateKey, className = '') {
    const input = el('input', `w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm ${className}`);
    input.placeholder = placeholder;
    input.value = appState[stateKey];
    input.addEventListener('change', e => {
        appState[stateKey] = e.target.value.trim();
        saveState();
    });
    return input;
  }

  // --- Event Handlers ---
  function handleChipClick(event) {
      const chip = event.target.closest('.chip');
      if (!chip) return;
      
      const option = chip.dataset.option;
      const stateKey = chip.parentElement.dataset.stateKey;
      const max = stateKey === 'selectedLanguages' ? 3 : 2;
      const stateArray = appState[stateKey];

      if (stateArray.includes(option)) {
          appState[stateKey] = stateArray.filter(x => x !== option);
      } else {
          appState[stateKey] = [...stateArray, option].slice(-max);
      }
      saveState();
      updateControls();
  }
  
  function handleLikedNamesClick(event) {
      const removeBtn = event.target.closest('[data-action="remove-liked"]');
      if (!removeBtn) return;

      const nameToRemove = removeBtn.dataset.name;
      appState.likedNames = appState.likedNames.filter(n => n.name !== nameToRemove);
      saveState();
      updateControls();
      updateResultsPanel();
  }
  
  function handleResultsPanelClick(event) {
      const copyBtn = event.target.closest('[data-action="copy-name"]');
      if (copyBtn) {
          navigator.clipboard.writeText(copyBtn.dataset.name);
          showToast('Copied!');
          return;
      }
      
      const likeBtn = event.target.closest('[data-action="like-name"]');
      if (likeBtn) {
          const name = likeBtn.dataset.name;
          const isLiked = appState.likedNames.some(n => n.name === name);

          if (isLiked) {
              appState.likedNames = appState.likedNames.filter(n => n.name !== name);
          } else {
              const nameObj = appState.results.find(r => r.name === name);
              if (nameObj) appState.likedNames.push(nameObj);
          }
          saveState();
          likeBtn.classList.toggle('active');
          updateLikedNamesSection();
          ui.controls.generateButton.textContent = appState.likedNames.length > 0 ? 'Riff on Liked' : 'Generate Names';
      }
  }

  function initLayout() {
    ui.root.innerHTML = '';
    const appWrap = el('div','max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-3 gap-6');
    const left = el('div','md-col-span-1 bg-[#071425] border border-[#0e2334] rounded-xl p-5 flex flex-col gap-4 h-fit');
    left.innerHTML = `<h1 class="text-xl font-semibold">Cultural Coinage</h1><div class="small-muted mt-1">Blend culture, sound & meaning</div>`;
    
    // API Key
    const apiKeySection = el('div');
    apiKeySection.innerHTML = `<label class="text-sm font-medium">Gemini API Key</label>`;
    const inputKey = el('input','w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm mt-1');
    inputKey.type = 'password'; inputKey.placeholder = 'Paste API key'; inputKey.value = appState.apiKey;
    inputKey.addEventListener('change', e => { appState.apiKey = e.target.value.trim(); saveState(); });
    apiKeySection.append(inputKey);

    // Context
    const contextSection = el('div');
    contextSection.innerHTML = `<label class="text-sm font-medium">Real-World Context (Optional)</label>`;
    const contextGrid = el('div', 'grid grid-cols-2 gap-2 mt-1');
    const surnameInput = createContextInput("Surname", "surname");
    const siblingsInput = createContextInput("Sibling Names", "siblingNames");
    const middleNameInput = createContextInput("First Name (for middle names)", "firstNameForMiddle", "col-span-2");
    contextGrid.append(surnameInput, siblingsInput, middleNameInput);
    contextSection.append(contextGrid);
    
    // Languages (Dynamic Chips)
    const languagesSection = el('div');
    languagesSection.innerHTML = `<label class="text-sm font-medium">Languages (choose 1–3)</label>`;
    ui.controls.languageChips = el('div', 'flex flex-wrap gap-2 mt-1');
    ui.controls.languageChips.dataset.stateKey = 'selectedLanguages';
    const addLangWrap = el('div', 'flex gap-2 mt-2');
    const langInput = el('input', 'w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm');
    langInput.placeholder = 'Add a language...';
    const addBtn = el('button', 'bg-[#0e2436] border border-[#1b3146] px-3 py-2 rounded text-sm small-muted');
    addBtn.textContent = 'Add';
    addBtn.addEventListener('click', () => {
        const newLang = langInput.value.trim();
        const allLangs = [...new Set([...LANG_OPTIONS, ...appState.userLanguages])];
        if (newLang && !allLangs.map(l => l.toLowerCase()).includes(newLang.toLowerCase())) {
            appState.userLanguages.push(newLang);
            appState.selectedLanguages = [...appState.selectedLanguages, newLang].slice(-3);
            saveState();
            updateControls();
        }
        langInput.value = '';
    });
    addLangWrap.append(langInput, addBtn);
    languagesSection.append(ui.controls.languageChips, addLangWrap);

    // Themes (Dynamic Chips)
    const themesSection = el('div');
    themesSection.innerHTML = `<label class="text-sm font-medium">Themes (choose 1–2)</label>`;
    ui.controls.themeChips = el('div', 'flex flex-wrap gap-2 mt-1');
    ui.controls.themeChips.dataset.stateKey = 'selectedThemes';
    themesSection.append(ui.controls.themeChips);

    // Style
    const styleSection = el('div');
    styleSection.innerHTML = `<label class="text-sm font-medium">Style</label>`;
    const styleSel = el('select','w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm mt-1');
    STYLE_OPTIONS.forEach(s => { const op = el('option'); op.value = s; op.textContent = s; if (appState.selectedStyle === s) op.selected = true; styleSel.append(op); });
    styleSel.addEventListener('change', e => { appState.selectedStyle = e.target.value; saveState(); });
    styleSection.append(styleSel);

    // Liked Names (Dynamic)
    ui.controls.likedNamesContainer = el('div');
    
    // Buttons
    const btnWrap = el('div','flex flex-wrap gap-2 mt-2');
    ui.controls.generateButton = el('button','bg-gradient-to-r from-[#3b82f6] to-[#2563eb] text-white px-4 py-2 rounded font-semibold shadow flex-1');
    ui.controls.generateButton.addEventListener('click', () => doGenerate('first'));
    const middleBtn = el('button','bg-[#1e3a8a] text-white px-4 py-2 rounded font-semibold shadow');
    middleBtn.textContent = 'Middle Names';
    middleBtn.addEventListener('click', () => doGenerate('middle'));
    const exportBtn = el('button','bg-[#0e2436] border border-[#1b3146] px-3 py-2 rounded text-sm small-muted');
    exportBtn.textContent = 'Export';
    exportBtn.addEventListener('click', exportCSV);
    const clearBtn = el('button','bg-transparent border border-[#233542] px-3 py-2 rounded text-sm small-muted');
    clearBtn.textContent = 'Clear';
    clearBtn.addEventListener('click', ()=>{ appState.results=[]; appState.error=null; updateResultsPanel(); });
    btnWrap.append(ui.controls.generateButton, middleBtn, exportBtn, clearBtn);
    
    // Assemble Controls
    left.append(apiKeySection, contextSection, languagesSection, themesSection, styleSection, ui.controls.likedNamesContainer, btnWrap);

    // Results Panel
    const right = el('div','md:col-span-2 bg-[#071427] border border-[#0e2030] rounded-xl p-5 flex flex-col gap-4');
    right.innerHTML = '<div><h2 class="text-lg font-semibold">Results</h2><div class="small-muted">Poetic, culturally coined names</div></div>';
    ui.results.panel = el('div','mt-2 p-3 bg-[#071a25] border border-[#0f2a3a] rounded-lg min-h-[280px] flex flex-col');
    right.append(ui.results.panel);

    // Add delegated listeners
    ui.controls.languageChips.addEventListener('click', handleChipClick);
    ui.controls.themeChips.addEventListener('click', handleChipClick);
    ui.controls.likedNamesContainer.addEventListener('click', handleLikedNamesClick);
    ui.results.panel.addEventListener('click', handleResultsPanelClick);
    
    appWrap.append(left, right);
    ui.root.append(appWrap);
  }

  function showToast(msg) {
    const t = el('div','fixed bottom-6 left-1/2 -translate-x-1/2 bg-[#0f2a41] px-4 py-2 rounded shadow text-sm fade');
    t.textContent = msg;
    document.body.appendChild(t);
    setTimeout(()=> t.remove(), 1400);
  }

  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  function buildSystemPrompt(task) {
    return `You are the Cultural Coinage Agent: craft short, poetic, pronounceable unisex names by blending the specified language origins and themes. Return output as a JSON array of objects (JSON only). Each object MUST have three keys: "name", "meaning", and "roots". The "roots" field is crucial: it must contain a detailed explanation of the linguistic and cultural origins for the name. Names should be 4–10 letters, 2–3 syllables preferred, culturally respectful, and have evocative (poetic) meanings. Task: ${task}`;
  }

  async function callGeminiOnce(prompt) {
    const key = appState.apiKey.trim();
    if (!key) throw new Error('Missing API key.');
    const body = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { temperature: 0.6, maxOutputTokens: 800, candidateCount: 1 } };
    const res = await fetch(API_BASE_URL + '?key=' + encodeURIComponent(key), { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
    if (!res.ok) throw new Error(`Gemini API error ${res.status}: ${await res.text()}`);
    const data = await res.json();
    return data?.candidates?.[0]?.content?.parts?.[0]?.text || "";
  }

  async function doGenerate(mode = 'first') {
    if (!appState.apiKey) {
        appState.error = "Please enter your Gemini API key to begin.";
        updateResultsPanel();
        return;
    }
    appState.error = null;
    appState.results = [];
    appState.isLoading = true;
    updateResultsPanel();

    let task;
    const allLangs = [...new Set([...appState.selectedLanguages, ...appState.userLanguages])];
    
    if (mode === 'middle') {
        if (!appState.firstNameForMiddle) { appState.error = "Please provide a first name to generate middle names."; appState.isLoading = false; updateResultsPanel(); return; }
        task = `Generate ${DEFAULT_COUNT} middle names for the first name "${appState.firstNameForMiddle}". Consider themes: ${appState.selectedThemes.join(', ')} and style: ${appState.selectedStyle}.`;
        if (appState.surname) task += ` The full name should flow well with the surname "${appState.surname}".`;
    } else if (appState.likedNames.length > 0) {
        const likedStr = appState.likedNames.map(n => n.name).join(', ');
        task = `Analyze these liked names: ${likedStr}. Generate ${DEFAULT_COUNT} new names in a similar style, using themes of ${appState.selectedThemes.join(', ')}.`;
    } else {
        task = `Languages: ${allLangs.join(', ')} | Themes: ${appState.selectedThemes.join(', ')} | Style: ${appState.selectedStyle} | Return ${DEFAULT_COUNT} names.`;
    }
    if (mode === 'first' && appState.siblingNames) task += ` Keep stylistically compatible with siblings: ${appState.siblingNames}.`;
    if (mode === 'first' && appState.surname) task += ` Harmonize with surname: ${appState.surname}.`;
    
    const prompt = buildSystemPrompt(task);
    try {
        const raw = await callGeminiOnce(prompt);
        let parsed = parseApiResponse(raw);
        appState.results = filterAndScore(parsed);
        if (!appState.results.length) {
            appState.error = "No suitable names generated. You can try adjusting your selections.";
        }
    } catch (err) {
      console.error('Generation error:', err);
      appState.error = err.message || String(err);
    } finally {
      appState.isLoading = false;
      updateResultsPanel();
    }
  }

  function exportCSV() {
    if (!appState.results.length) { showToast('No results'); return; }
    const header = ['Name','Meaning','Roots','Score'];
    const rows = appState.results.map(r => [`"${r.name.replace(/"/g,'""')}"`,`"${(r.meaning||'').replace(/"/g,'""')}"`,`"${(r.roots||'').replace(/"/g,'""')}"`, r.score].join(','));
    const csv = [header.join(','), ...rows].join('\r\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = el('a'); a.href = url; a.download = `cultural-coinage-${Date.now()}.csv`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    showToast('Exported CSV');
  }

  // --- Init ---
  loadState();
  initLayout();
  updateControls();
  updateResultsPanel();
})();
  </script>
</body>
</html>

