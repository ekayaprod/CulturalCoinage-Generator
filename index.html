<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cultural Coinage Generator</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#071022; color:#E6EEF9; }
    .scrolling-panel::-webkit-scrollbar{ width:10px } .scrolling-panel::-webkit-scrollbar-thumb{ background:#213449; border-radius:8px }
    .fade { animation: fade 220ms ease-out; } @keyframes fade{ from{opacity:0; transform:translateY(6px)} to{opacity:1; transform:none} }
    .small-muted { color:#9fb0c7; font-size:13px }
    .chip { padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); cursor:pointer; user-select:none }
    .chip.active { background: linear-gradient(90deg,#294e86,#2b6fb3); color:white; box-shadow:0 6px 18px rgba(41,78,134,0.14) }
    .spinner{ border:4px solid rgba(255,255,255,0.06); border-top-color:#60a5fa; border-radius:999px; width:36px; height:36px; animation:spin 0.9s linear infinite } @keyframes spin{ to{transform:rotate(360deg)} }
    a.debug { color:#8fb6ff; text-decoration:underline }
    .debug-panel { max-height: 200px; overflow-y: auto; }
  </style>
</head>
<body>
  <div id="app" class="min-h-screen p-6"></div>

  <script>
(function () {
  // Philosophy for LLMs
  const PHILOSOPHY = `
  CULTURAL COINAGE GENERATOR

  Names are artifacts, not random strings.
  Blend cultural morphemes, syllables, and phonetic textures into poetic,
  pronounceable names that are culturally respectful.

  North Star: Treat this tool as a craft workshop, not just a generator.
  All contributors and LLMs must preserve this intent.
  `;

  // --- CONFIG ---
  const API_BASE_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent";
  const DEFAULT_COUNT = 6;
  const LANG_OPTIONS = ["Turkish","Nordic","Latin","Celtic","Slavic","Japanese","Greek","Sanskrit","Arabic"];
  const THEME_OPTIONS = ["Nature","Cosmic","Balance","Strength","Water","Light","Shadow","Music", "Fire", "Mountain", "Ocean", "Sky", "Forest", "Mythic"];
  const STYLE_OPTIONS = ["Lyrical & Melodic","Archaic & Mythic","Minimalist & Modern","Heroic & Resonant", "Elegant & Refined", "Grounded & Earthy", "Mystical & Ethereal"];

  // --- State ---
  const appState = {
    apiKey: "",
    isLoading: false,
    error: null,
    results: [],
    likedNames: [],
    selectedLanguages: ["Celtic", "Sanskrit"],
    selectedThemes: ["Light","Balance"],
    selectedStyle: "Lyrical & Melodic",
    gender: "Unisex",
    surname: "",
    siblingNames: "",
    firstNameForMiddle: "",
    userLanguages: [],
    userBlacklist: [],
    rawApiResponse: null,
    sessionGeneratedNames: [],
    outputAlphabet: "English",
  };
  
  // --- UI Element Cache ---
  const ui = {
      root: document.getElementById('app'),
      controls: {},
      results: {}
  };

  // --- Helpers ---
  const el = (tag, cls='') => { const d = document.createElement(tag); if (cls) d.className = cls; return d; };
  
  function saveState() {
    try {
        const stateToSave = {
            apiKey: appState.apiKey,
            selectedLanguages: appState.selectedLanguages,
            selectedThemes: appState.selectedThemes,
            selectedStyle: appState.selectedStyle,
            likedNames: appState.likedNames,
            userLanguages: appState.userLanguages,
            surname: appState.surname,
            siblingNames: appState.siblingNames,
            firstNameForMiddle: appState.firstNameForMiddle,
            userBlacklist: appState.userBlacklist,
            gender: appState.gender,
            outputAlphabet: appState.outputAlphabet,
        };
        localStorage.setItem('culturalCoinageState', JSON.stringify(stateToSave));
    } catch (e) { console.warn("Could not save state to localStorage:", e); }
  }

  function loadState() {
      try {
        const saved = localStorage.getItem('culturalCoinageState');
        if (saved) {
            const parsed = JSON.parse(saved);
            const defaults = { likedNames: [], userLanguages: [], userBlacklist: [], gender: "Unisex", outputAlphabet: "English" };
            Object.assign(appState, { ...defaults, ...parsed });
        }
      } catch (e) { console.warn("Could not load state from localStorage:", e); }
  }

  function parseApiResponse(text) {
    if (!text) return [];
    let cleanedText = text.replace(/```[a-z]*\n?/gi, '').replace(/```/g, '').trim();

    try {
      const parsed = JSON.parse(cleanedText);
      if (Array.isArray(parsed)) return parsed;
      if (parsed.names && Array.isArray(parsed.names)) return parsed.names;
      if (typeof parsed === "object") return Object.values(parsed).flat();
    } catch (e) {
      console.warn("Strict JSON parse failed. Falling back to multi-regex.", e);
    }

    // Fallback: Regex for objects within the text
    const results = [];
    const objectRegex = /{\s*"name":\s*"([^"]+)",\s*"meaning":\s*"([^"]+)",\s*"roots":\s*"([^"]+)",\s*"cluster":\s*"([^"]+)"\s*}/g;
    let match;
    while ((match = objectRegex.exec(cleanedText)) !== null) {
      results.push({
        name: match[1],
        meaning: match[2],
        roots: match[3],
        cluster: match[4],
      });
    }
    if (results.length > 0) return results;

    // Final fallback: Regex for names only if object parsing fails
    const nameMatches = [...cleanedText.matchAll(/"name"\s*:\s*"([^"]+)"/g)];
    return nameMatches.map(m => ({ name: m[1], meaning: "", roots: "", cluster: "" }));
  }

  function processApiResponse(rawArray) {
    if (!rawArray?.length) return [];
    const fullBlacklist = appState.userBlacklist.map(b => b.toLowerCase());

    return rawArray.map(it => {
      let name = (it.name || "").toString().trim();
      let meaning = (it.meaning || "").toString().trim();
      let roots = (it.roots || "").toString().trim();
      let cluster = (it.cluster || "").toString().trim() || appState.selectedStyle;

      if (!name) return null; // Filter out empty name objects
      if (fullBlacklist.some(b => name.toLowerCase().includes(b))) return null;

      if (!meaning) {
        meaning = `A name evoking ${appState.selectedThemes.join(" and ").toLowerCase()}, with roots in ${appState.selectedLanguages.join(' & ')}.`;
      } else if (meaning.split(/\s+/).length < 3) {
        meaning = `${meaning} — a name that evokes ${appState.selectedThemes.join(" and ").toLowerCase()}.`;
      }

      return { name, meaning, roots, cluster };
    }).filter(Boolean);
  }

  // --- UI Update Functions ---
  function updateResultsPanel() {
      ui.results.panel.innerHTML = '';
      if (appState.isLoading) {
          ui.results.panel.innerHTML = '<div class="flex items-center justify-center py-8"><div class="spinner"></div></div>';
      } else if (appState.error) {
          ui.results.panel.innerHTML = `<div class="bg-[#2b1a1a] border border-[#5b2626] rounded p-4"><div class="text-red-300 font-semibold">Error</div><div class="small-muted mt-2">${escapeHtml(appState.error)}</div></div>`;
          updateDebugViewer();
      } else if (!appState.results.length) {
          ui.results.panel.innerHTML = '<div class="flex-1 flex items-center justify-center small-muted h-full">No names yet — click Generate.</div>';
          updateDebugViewer();
      } else {
          const clusters = appState.results.reduce((acc, item) => {
              (acc[item.cluster] = acc[item.cluster] || []).push(item);
              return acc;
          }, {});

          Object.keys(clusters).sort().forEach(clusterName => {
              const clusterTitle = el('h3', 'text-md font-semibold text-blue-300 mt-4 first:mt-0');
              clusterTitle.textContent = clusterName;
              ui.results.panel.append(clusterTitle);
              
              const grid = el('div','grid grid-cols-1 sm:grid-cols-2 gap-4 mt-2');
              clusters[clusterName].forEach(item => grid.append(createNameCard(item)));
              ui.results.panel.append(grid);
          });
      }
  }
  
  function updateControls() {
    updateChipSelector(ui.controls.languageChips, [...new Set([...LANG_OPTIONS, ...appState.userLanguages])]);
    updateChipSelector(ui.controls.themeChips, THEME_OPTIONS);
    updateLikedNamesSection();
    updateUserBlacklist();
    ui.controls.generateButton.textContent = appState.likedNames.length > 0 ? 'Riff on Liked' : 'Generate Names';
  }

  function updateChipSelector(container, options) {
      container.innerHTML = '';
      const stateKey = container.dataset.stateKey;
      options.forEach(opt => {
          const c = el('button', 'chip'); c.textContent = opt; c.dataset.option = opt;
          if (appState[stateKey].includes(opt)) c.classList.add('active');
          container.append(c);
      });
  }
  
  function updateUserBlacklist() {
      ui.controls.blacklistChips.innerHTML = '';
      appState.userBlacklist.forEach(word => {
          const chip = el('div', 'chip flex items-center gap-2');
          chip.innerHTML = `<span>${word}</span><button class="font-mono text-xs opacity-70" data-action="remove-blacklist" data-word="${word}">x</button>`;
          ui.controls.blacklistChips.append(chip);
      });
  }

  function updateLikedNamesSection() {
      ui.controls.likedNamesContainer.innerHTML = '';
      if (appState.likedNames.length > 0) {
        const label = el('label', 'text-sm font-medium'); label.textContent = 'Liked Names (Inspiration)';
        const wrap = el('div', 'flex flex-wrap gap-2 mt-1');
        appState.likedNames.forEach(nameObj => {
            const chip = el('div', 'chip active flex items-center gap-2');
            chip.innerHTML = `<span>${nameObj.name}</span><button class="font-mono text-xs opacity-70" data-action="remove-liked" data-name="${nameObj.name}">x</button>`;
            wrap.append(chip);
        });
        ui.controls.likedNamesContainer.append(label, wrap);
      }
  }

  function updateDebugViewer() {
    ui.debug.container.innerHTML = '';
    if (appState.rawApiResponse) {
      const details = el('details', 'mt-4');
      details.innerHTML = `<summary class="cursor-pointer text-sm small-muted">Show Raw Model Output</summary>
      <pre class="debug-panel bg-[#0b1622] border border-[#223447] rounded p-2 text-xs mt-2 whitespace-pre-wrap"></pre>
      <div class="flex gap-2 mt-2">
        <button class="chip" data-action="copy-debug">Copy Raw</button>
        <button class="chip" data-action="copy-parsed">Copy Parsed</button>
      </div>`;
      details.querySelector('pre').textContent = appState.rawApiResponse;
      ui.debug.container.append(details);
    }
  }

  // --- UI Creation ---
  function createNameCard(item) {
      const isLiked = appState.likedNames.some(n => n.name === item.name);
      const card = el('div','bg-[#081426] border border-[#123047] rounded p-4 flex flex-col gap-2 fade');
      
      const header = el('div', 'flex items-start justify-between gap-2');
      const nameEl = el('div', 'text-xl font-semibold'); nameEl.textContent = item.name;
      header.append(nameEl);

      const meaningEl = el('div', 'italic small-muted'); meaningEl.textContent = item.meaning || '—';
      
      const rootsEl = el('div', 'text-xs mt-auto small-muted');
      const strongTag = el('strong');
      strongTag.textContent = 'Roots: ';
      rootsEl.append(strongTag, document.createTextNode(item.roots || '—'));
      
      const actions = el('div', 'flex flex-wrap gap-2 mt-2');
      const copyBtn = el('button', 'chip');
      copyBtn.dataset.action = 'copy-name';
      copyBtn.dataset.name = item.name;
      copyBtn.textContent = 'Copy';

      const likeBtn = el('button', `chip ${isLiked ? 'active' : ''}`);
      likeBtn.dataset.action = 'like-name';
      likeBtn.dataset.name = item.name;
      likeBtn.innerHTML = '&hearts; Like';

      const variantsBtn = el('button', 'chip');
      variantsBtn.dataset.action = 'variants';
      variantsBtn.dataset.name = item.name;
      variantsBtn.textContent = 'Variants';
      
      actions.append(copyBtn, likeBtn, variantsBtn);
      
      card.append(header, meaningEl, rootsEl, actions);
      return card;
  }
  
  function createContextInput(placeholder, stateKey, className = '') {
    const input = el('input', `w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm ${className}`);
    input.placeholder = placeholder; input.value = appState[stateKey];
    input.addEventListener('change', e => { appState[stateKey] = e.target.value.trim(); saveState(); });
    return input;
  }

  function createAddButton(clickHandler) {
    const btn = el('button', 'bg-[#0e2436] border border-[#1b3146] px-3 py-2 rounded text-sm small-muted');
    btn.textContent = 'Add';
    btn.addEventListener('click', clickHandler);
    return btn;
  }

  // --- Event Handlers ---
  function handleControlsClick(event) {
      const chip = event.target.closest('.chip[data-option]');
      if (chip) {
          const option = chip.dataset.option;
          const stateKey = chip.parentElement.dataset.stateKey;
          const max = stateKey === 'selectedLanguages' ? 3 : 2;
          appState[stateKey] = appState[stateKey].includes(option)
              ? appState[stateKey].filter(x => x !== option)
              : [...appState[stateKey], option].slice(-max);
          saveState();
          updateControls();
          return;
      }

      const removeLikedBtn = event.target.closest('[data-action="remove-liked"]');
      if (removeLikedBtn) {
          appState.likedNames = appState.likedNames.filter(n => n.name !== removeLikedBtn.dataset.name);
          saveState();
          updateControls();
          updateResultsPanel();
          return;
      }
      
      const removeBlacklistBtn = event.target.closest('[data-action="remove-blacklist"]');
      if(removeBlacklistBtn) {
          appState.userBlacklist = appState.userBlacklist.filter(w => w !== removeBlacklistBtn.dataset.word);
          saveState();
          updateUserBlacklist();
      }
  }
  
  function handleResultsPanelClick(event) {
      const btn = event.target.closest('button[data-action]');
      if (!btn) return;
      const { action, name } = btn.dataset;
      
      if (action === 'copy-name') {
          navigator.clipboard.writeText(name);
          showToast('Copied!');
      } else if (action === 'like-name') {
          const isLiked = appState.likedNames.some(n => n.name === name);
          if (isLiked) {
              appState.likedNames = appState.likedNames.filter(n => n.name !== name);
              showToast('Unliked!');
          } else {
              const nameObj = appState.results.find(r => r.name === name);
              if (nameObj) appState.likedNames.push(nameObj);
              showToast('Liked!');
          }
          saveState();
          btn.classList.toggle('active');
          updateLikedNamesSection();
          ui.controls.generateButton.textContent = appState.likedNames.length > 0 ? 'Riff on Liked' : 'Generate Names';
      } else if (action === 'variants') {
          doGenerate('variants', name);
      } else if (action === 'copy-debug') {
          navigator.clipboard.writeText(appState.rawApiResponse);
          showToast('Copied Raw Output!');
      } else if (action === 'copy-parsed') {
          navigator.clipboard.writeText(JSON.stringify(appState.results, null, 2));
          showToast('Copied Parsed JSON!');
      }
  }

  function initLayout() {
    ui.root.innerHTML = '';
    const appWrap = el('div','max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-3 gap-6');
    const left = el('div','md-col-span-1 bg-[#071425] border border-[#0e2334] rounded-xl p-5 flex flex-col gap-4 h-fit');
    left.innerHTML = `<h1 class="text-xl font-semibold">Cultural Coinage</h1><div class="small-muted mt-1">Blend culture, sound & meaning</div>`;
    
    const apiKeySection = el('div');
    apiKeySection.innerHTML = `<label class="text-sm font-medium">Gemini API Key</label>`;
    const inputKey = el('input','w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm mt-1');
    inputKey.type = 'password'; inputKey.placeholder = 'Paste API key'; inputKey.value = appState.apiKey;
    inputKey.addEventListener('change', e => { appState.apiKey = e.target.value.trim(); saveState(); });
    apiKeySection.append(inputKey);

    const contextSection = el('div');
    contextSection.innerHTML = `<label class="text-sm font-medium">Real-World Context (Optional)</label>`;
    const contextGrid = el('div', 'grid grid-cols-2 gap-2 mt-1');
    contextGrid.append(createContextInput("Surname", "surname"), createContextInput("Sibling Names", "siblingNames"), createContextInput("First Name (for middle names)", "firstNameForMiddle", "col-span-2"));
    contextSection.append(contextGrid);
    
    const languagesSection = el('div');
    languagesSection.innerHTML = `<label class="text-sm font-medium">Languages (choose 1–3)</label>`;
    ui.controls.languageChips = el('div', 'flex flex-wrap gap-2 mt-1');
    ui.controls.languageChips.dataset.stateKey = 'selectedLanguages';
    const addLangWrap = el('div', 'flex gap-2 mt-2');
    const langInput = el('input', 'w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm');
    langInput.placeholder = 'Add a language...';
    const addLangBtn = createAddButton(() => {
        const newLang = langInput.value.trim();
        const allLangs = [...new Set([...LANG_OPTIONS, ...appState.userLanguages])];
        if (newLang && !allLangs.map(l => l.toLowerCase()).includes(newLang.toLowerCase())) {
            appState.userLanguages.push(newLang);
            appState.selectedLanguages = [...appState.selectedLanguages, newLang].slice(-3);
            saveState(); updateControls();
        }
        langInput.value = '';
    });
    addLangWrap.append(langInput, addLangBtn);
    languagesSection.append(ui.controls.languageChips, addLangWrap);

    const themesSection = el('div');
    themesSection.innerHTML = `<label class="text-sm font-medium">Themes (choose 1–2)</label>`;
    ui.controls.themeChips = el('div', 'flex flex-wrap gap-2 mt-1');
    ui.controls.themeChips.dataset.stateKey = 'selectedThemes';
    themesSection.append(ui.controls.themeChips);

    const styleSection = el('div');
    styleSection.innerHTML = `<label class="text-sm font-medium">Style</label>`;
    const styleSel = el('select','w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm mt-1');
    STYLE_OPTIONS.forEach(s => { const op = el('option'); op.value = s; op.textContent = s; if (appState.selectedStyle === s) op.selected = true; styleSel.append(op); });
    styleSel.addEventListener('change', e => { appState.selectedStyle = e.target.value; saveState(); });
    styleSection.append(styleSel);
    
    const genderSection = el('div');
    genderSection.innerHTML = `<label class="text-sm font-medium">Gender</label>`;
    const genderSel = el('select','w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm mt-1');
    ["Unisex","Male","Female"].forEach(g => { 
      const op = el('option'); op.value = g; op.textContent = g; 
      if (appState.gender === g) op.selected = true; 
      genderSel.append(op); 
    });
    genderSel.addEventListener('change', e => { appState.gender = e.target.value; saveState(); });
    genderSection.append(genderSel);

    const alphabetSection = el('div');
    alphabetSection.innerHTML = `<label class="text-sm font-medium">Output Alphabet</label>`;
    const alphabetSel = el('select','w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm mt-1');
    ["English"].forEach(a => { // Can be expanded later
        const op = el('option'); op.value = a; op.textContent = a;
        if(appState.outputAlphabet === a) op.selected = true;
        alphabetSel.append(op);
    });
    alphabetSel.addEventListener('change', e => { appState.outputAlphabet = e.target.value; saveState(); });
    alphabetSection.append(alphabetSel);

    const blacklistSection = el('div');
    blacklistSection.innerHTML = `<label class="text-sm font-medium">User Blacklist</label>`;
    ui.controls.blacklistChips = el('div', 'flex flex-wrap gap-2 mt-1');
    const addBlacklistWrap = el('div', 'flex gap-2 mt-2');
    const blacklistInput = el('input', 'w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm');
    blacklistInput.placeholder = 'Add a word to blacklist...';
    const addBlacklistBtn = createAddButton(() => {
        const newWord = blacklistInput.value.trim().toLowerCase();
        if (newWord && !appState.userBlacklist.includes(newWord)) {
            appState.userBlacklist.push(newWord);
            saveState(); updateUserBlacklist();
        }
        blacklistInput.value = '';
    });
    addBlacklistWrap.append(blacklistInput, addBlacklistBtn);
    blacklistSection.append(ui.controls.blacklistChips, addBlacklistWrap);

    ui.controls.likedNamesContainer = el('div');
    
    const btnWrap = el('div','flex flex-wrap gap-2 mt-2');
    ui.controls.generateButton = el('button','bg-gradient-to-r from-[#3b82f6] to-[#2563eb] text-white px-4 py-2 rounded font-semibold shadow flex-1');
    ui.controls.generateButton.addEventListener('click', () => doGenerate('first'));
    const middleBtn = el('button','bg-[#1e3a8a] text-white px-4 py-2 rounded font-semibold shadow'); middleBtn.textContent = 'Middle Names';
    middleBtn.addEventListener('click', () => doGenerate('middle'));
    const exportBtn = el('button','bg-[#0e2436] border border-[#1b3146] px-3 py-2 rounded text-sm small-muted'); exportBtn.textContent = 'Export';
    exportBtn.addEventListener('click', exportCSV);
    const clearBtn = el('button','bg-transparent border border-[#233542] px-3 py-2 rounded text-sm small-muted'); clearBtn.textContent = 'Clear';
    clearBtn.addEventListener('click', ()=>{ appState.results=[]; appState.error=null; appState.rawApiResponse=null; appState.sessionGeneratedNames = []; updateResultsPanel(); });
    btnWrap.append(ui.controls.generateButton, middleBtn, exportBtn, clearBtn);
    
    const controlsContainer = el('div'); 
    controlsContainer.append(apiKeySection, contextSection, languagesSection, themesSection, styleSection, genderSection, alphabetSection, ui.controls.likedNamesContainer, blacklistSection, btnWrap);
    left.append(controlsContainer);

    const right = el('div','md:col-span-2 bg-[#071427] border border-[#0e2030] rounded-xl p-5 flex flex-col gap-4');
    const resultsHeader = el('div');
    resultsHeader.innerHTML = '<div><h2 class="text-lg font-semibold">Results</h2><div class="small-muted">Poetic, culturally coined names</div></div>';
    
    ui.results.panel = el('div','mt-2 p-3 bg-[#071a25] border border-[#0f2a3a] rounded-lg min-h-[280px] flex flex-col');
    ui.debug = { container: el('div') };
    right.append(resultsHeader, ui.results.panel, ui.debug.container);

    controlsContainer.addEventListener('click', handleControlsClick);
    right.addEventListener('click', handleResultsPanelClick);
    
    appWrap.append(left, right);
    ui.root.append(appWrap);
  }

  function showToast(msg) {
    const t = el('div','fixed bottom-6 left-1/2 -translate-x-1/2 bg-[#0f2a41] px-4 py-2 rounded shadow text-sm fade');
    t.textContent = msg; document.body.appendChild(t);
    setTimeout(()=> t.remove(), 1400);
  }

  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  function buildSystemPrompt(task, gender, sessionHistory, outputAlphabet) {
    const fullBlacklist = [...appState.userBlacklist];
    const sessionMemoryInstruction = sessionHistory.length > 0
      ? `Avoid repeating or too closely resembling these session names: ${sessionHistory.join(', ')}. Instead, explore new combinations in a similar spirit.`
      : `This is the first generation of this session.`;

    return `
You are the Cultural Coinage Agent — a poet-linguist, not a random generator. 
Your craft is name-smithing: fusing cultural morphemes into new, resonant names that feel alive, meaningful, and poetic.

PRINCIPLES:
- Names are artifacts, not random strings. The 'meaning' and 'roots' fields must be distinct.
- Use only morphemes and etymologies from the languages listed in TASK. Do not include other languages. If a gap exists, invent a new coined root marked as (coined).
- Adapt with creativity: use phonological glue (connecting vowels, softened endings), and reshape roots for flow.
- Balance sound and meaning: each name must have resonance and a story.
- Roots Clarity: Spell out each part of the root, e.g., "astro (Greek: star) + ren (Nordic: raven)". This field is for the technical breakdown.
- Meaning: This field is for a short, separate poetic interpretation of the name's feeling, NOT a repeat of the roots.
- Style must follow the selected tone (lyrical, archaic, heroic, etc.).

SESSION CONTEXT:
${sessionMemoryInstruction}
Blacklist: ${fullBlacklist.join(", ")}
Contextual harmony: Consider sibling names, surnames, and gender preference.
Gender Guidance:
- Male: favor consonant-final/strong clusters, firmer endings.
- Female: favor open syllables, vowel-rich endings and melodic cadence.
- Unisex: neutral balance; prefer flexible endings.

FINAL STEP (MANDATORY):
After coining a name, you MUST transliterate it to the specified '${outputAlphabet}' alphabet. For example, Kıvanç becomes Kivanc, Sølvag becomes Solvag, Rónán becomes Ronan. The final 'name' in the JSON must use only '${outputAlphabet}' characters.

OUTPUT FORMAT:
Return ONLY a raw JSON array of objects, with no markdown or text wrapping. 
Each object must look like this:
{
  "name": "Astren",
  "meaning": "A name that evokes cosmic guidance and strength",
  "roots": "astro (Greek: star) + ren (Nordic: raven)",
  "cluster": "${appState.selectedStyle}"
}

TASK:
${task}
    `;
  }

  async function callGeminiOnce(prompt) {
    const key = appState.apiKey.trim();
    if (!key) throw new Error('Missing API key.');
    const body = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { temperature: 0.8, maxOutputTokens: 1200, candidateCount: 1 } };
    const res = await fetch(API_BASE_URL + '?key=' + encodeURIComponent(key), { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
    if (!res.ok) throw new Error(`Gemini API error ${res.status}: ${await res.text()}`);
    const data = await res.json();
    return data?.candidates?.[0]?.content?.parts?.[0]?.text || "";
  }

  async function doGenerate(mode = 'first', contextName = '') {
    if (!appState.apiKey) {
        appState.error = "Please enter your Gemini API key to begin."; updateResultsPanel(); return;
    }
    appState.error = null; appState.results = []; appState.rawApiResponse = null; appState.isLoading = true;
    updateResultsPanel();

    if (appState.sessionGeneratedNames.length > 30) {
      appState.sessionGeneratedNames = appState.sessionGeneratedNames.slice(-30);
    }

    let task;
    const allLangs = [...new Set([...appState.selectedLanguages, ...appState.userLanguages])];

    if (mode === 'middle') {
        if (!appState.firstNameForMiddle) { appState.error = "Please provide a first name to generate middle names."; appState.isLoading = false; updateResultsPanel(); return; }
        task = `Generate ${DEFAULT_COUNT} middle names for "${appState.firstNameForMiddle}" using morphemes exclusively from these languages: ${allLangs.join(', ')}. All names must embody the "${appState.selectedStyle}" style. Draw thematic inspiration from: ${appState.selectedThemes.join(', ')}.`;
    } else if (mode === 'variants') {
        task = `Generate ${DEFAULT_COUNT} variants of the name "${contextName}". These must have at least 50% phonetic overlap and not be simple respellings. Use morphemes from: ${allLangs.join(', ')} and embody the "${appState.selectedStyle}" style.`;
    } else if (appState.likedNames.length > 0) {
        const likedStr = appState.likedNames.map(n => n.name).join(', ');
        task = `Analyze these liked names: ${likedStr}. Generate ${DEFAULT_COUNT} new names that embody the "${appState.selectedStyle}" style using morphemes exclusively from these languages: ${allLangs.join(', ')}. Draw thematic inspiration from: ${appState.selectedThemes.join(', ')}.`;
    } else {
        task = `Generate ${DEFAULT_COUNT} original names that embody the "${appState.selectedStyle}" style using morphemes exclusively from these languages: ${allLangs.join(', ')}. Draw thematic inspiration from: ${appState.selectedThemes.join(', ')}.`;
    }
    if (appState.siblingNames) task += ` Harmonize stylistically with existing siblings: ${appState.siblingNames.join(', ')}.`;
    if (appState.surname) task += ` Consider compatibility with surname: ${appState.surname}.`;
    
    let prompt = buildSystemPrompt(task, appState.gender, appState.sessionGeneratedNames, appState.outputAlphabet);
    try {
        const raw = await callGeminiOnce(prompt);
        appState.rawApiResponse = raw;
        const parsed = parseApiResponse(raw);
        
        const processed = processApiResponse(parsed);
        if (processed.length) {
            appState.sessionGeneratedNames.push(...processed.map(p => p.name));
        }

        appState.results = processed;
        if (!appState.results.length) {
            appState.error = "No names could be parsed from the model output. Raw response saved below for debugging.";
        }
    } catch (err) {
      console.error('Generation error:', err);
      appState.error = err.message || String(err);
    } finally {
      appState.isLoading = false;
      updateResultsPanel();
    }
  }

  function exportCSV() {
    if (!appState.results.length) { showToast('No results'); return; }
    const header = ['Name','Meaning','Roots','Cluster'];
    const rows = appState.results.map(r => [`"${r.name.replace(/"/g,'""')}"`,`"${(r.meaning||'').replace(/"/g,'""')}"`,`"${(r.roots||'').replace(/"/g,'""')}"`, `"${r.cluster.replace(/"/g,'""')}"`].join(','));
    const csv = [header.join(','), ...rows].join('\r\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = el('a'); a.href = url; a.download = `cultural-coinage-${Date.now()}.csv`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    showToast('Exported CSV');
  }

  // --- Init ---
  loadState();
  initLayout();
  updateControls();
  updateResultsPanel();
})();
  </script>
</body>
</html>

