<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NameForge</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#071022; color:#E6EEF9; }
    .scrolling-panel::-webkit-scrollbar{ width:10px } .scrolling-panel::-webkit-scrollbar-thumb{ background:#213449; border-radius:8px }
    .fade { animation: fade 220ms ease-out; } @keyframes fade{ from{opacity:0; transform:translateY(6px)} to{opacity:1; transform:none} }
    .small-muted { color:#9fb0c7; font-size:13px }
    .chip { padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); cursor:pointer; user-select:none; display: inline-flex; align-items: center; gap: 4px; }
    .chip.active { background: linear-gradient(90deg,#294e86,#2b6fb3); color:white; box-shadow:0 6px 18px rgba(41,78,134,0.14) }
    .spinner{ border:4px solid rgba(255,255,255,0.06); border-top-color:#60a5fa; border-radius:999px; width:36px; height:36px; animation:spin 0.9s linear infinite } @keyframes spin{ to{transform:rotate(360deg)} }
    .progress-bar { height: 4px; background: rgba(255,255,255,0.1); border-radius: 999px; }
    .progress-fill { height: 100%; background: #60a5fa; border-radius: 999px; transition: width 0.2s ease-out; }
    .cultural-origin { font-size: 10px; padding: 2px 6px; border-radius: 4px; font-weight: 600; text-transform: uppercase; }
    .origin-default { background-color: #4b5563; color: #f3f4f6; }
    .modal-backdrop { display: none; position: fixed; inset: 0; background-color: rgba(0,0,0,0.6); backdrop-filter: blur(4px); animation: fadeIn 150ms ease-out; z-index: 50; }
    @keyframes fadeIn { from { opacity: 0 } to { opacity: 1 } }
    .modal-content { animation: slideIn 200ms ease-out; }
    @keyframes slideIn { from { opacity: 0; transform: translateY(20px) } to { opacity: 1; transform: translateY(0) } }
    .mode-toggle { display: flex; background: rgba(255,255,255,0.03); border-radius: 999px; padding: 4px; }
    .mode-toggle button { flex: 1; text-align: center; padding: 6px 10px; border-radius: 999px; border: none; background: transparent; color: #9fb0c7; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 150ms ease-out; }
    .mode-toggle button.active { background: linear-gradient(90deg,#294e86,#2b6fb3); color: white; box-shadow: 0 4px 10px rgba(41,78,134,0.1); }
    .toggle-switch { display: flex; align-items: center; justify-content: space-between; background: rgba(255,255,255,0.03); padding: 8px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); }
    .toggle-switch-input { height: 0; width: 0; visibility: hidden; }
    .toggle-switch-label { cursor: pointer; text-indent: -9999px; width: 40px; height: 22px; background: #374151; display: block; border-radius: 100px; position: relative; }
    .toggle-switch-label:after { content: ''; position: absolute; top: 2px; left: 2px; width: 18px; height: 18px; background: #fff; border-radius: 90px; transition: 0.2s; }
    .toggle-switch-input:checked + .toggle-switch-label { background: #2563eb; }
    .toggle-switch-input:checked + .toggle-switch-label:after { left: calc(100% - 2px); transform: translateX(-100%); }
  </style>
</head>
<body>
  <div id="app" class="min-h-screen p-6"></div>

  <script>
(function () {
  // --- CONFIG ---
  const API_BASE_URL = "https://generativelanguage.googleapis.com/v1beta/";
  const APP_VERSION = "8.0"; // View Prompt Feature
  const LANG_OPTIONS = ["Turkish","Nordic","Latin","Celtic","Japanese","Greek","Spanish","Irish", "Russian", "Korean", "English"];
  const THEME_OPTIONS = ["Nature","Cosmic","Balance","Strength","Water","Light","Shadow","Music", "Fire", "Mountain", "Ocean", "Sky", "Forest", "Mythic"];
  const STYLE_OPTIONS = ["Lyrical & Melodic","Archaic & Mythic","Minimalist & Modern","Heroic & Resonant", "Elegant & Refined", "Grounded & Earthy", "Mystical & Ethereal"];
  const MODEL_OPTIONS = [
    { value: "models/gemini-2.5-flash", text: "2.5 Flash (Fast & Balanced)" },
    { value: "models/gemini-2.5-pro", text: "2.5 Pro (Highest Quality)" },
    { value: "models/gemini-2.5-pro-preview-06-05", text: "2.5 Pro Preview (Latest)" },
    { value: "models/gemini-1.5-pro", text: "1.5 Pro (Legacy)" }
  ];

  // --- State ---
  const appState = {
    version: APP_VERSION,
    mode: 'forge',
    harmonizerIsAllLanguages: false,
    apiKey: "",
    isLoading: false,
    error: null,
    results: [],
    likedNames: [],
    selectedLanguages: ["Spanish", "Irish"],
    selectedThemes: ["Light","Balance"],
    selectedStyle: "Lyrical & Melodic",
    gender: "Unisex",
    surname: "",
    siblingNames: "",
    firstNameForMiddle: "",
    userLanguages: [],
    userBlacklist: [],
    rawApiResponse: null,
    sessionGeneratedNames: [],
    model: "models/gemini-2.5-flash",
    outputAlphabet: "English (Default)",
    generationController: null,
    recentErrors: [],
    hasSeenIntro: false,
    // New configurable settings
    defaultCount: 6,
    apiTimeout: 60, // in seconds
    maxOutputTokens: 1200,
    parallelMode: false,
  };
  
  // --- UI Element Cache ---
  const ui = {
      root: document.getElementById('app'),
      controls: {},
      results: {},
      modals: {},
  };

  // --- Helpers ---
  const el = (tag, cls='') => { const d = document.createElement(tag); if (cls) d.className = cls; return d; };
  const debounce = (func, delay) => {
    let timeout;
    return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), delay); };
  };
  const debouncedSaveState = debounce(saveState, 500);
  const showToast = (msg, isError = false) => {
    const t = el('div', `fixed bottom-6 left-1/2 -translate-x-1/2 px-4 py-2 rounded shadow text-sm fade ${isError ? 'bg-red-800' : 'bg-[#0f2a41]'} text-white z-50`);
    t.textContent = msg; document.body.appendChild(t);
    setTimeout(() => t.remove(), 3000);
  };

  function toggleModal(modal, show) {
    if (modal) {
        modal.style.display = show ? 'flex' : 'none';
        document.body.style.overflow = show ? 'hidden' : '';
    }
  }
  
  function createControlSection(label, controlElement) {
    const section = el('div');
    const labelEl = el('label', 'text-sm font-medium');
    labelEl.textContent = label;
    controlElement.classList.add('mt-1');
    section.append(labelEl, controlElement);
    return section;
  }

  function createSelectControl(options, selectedValue, changeHandler) {
      const select = el('select', 'w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm');
      options.forEach(opt => {
          const optionEl = el('option');
          if (typeof opt === 'object') {
            optionEl.value = opt.value;
            optionEl.textContent = opt.text;
          } else {
            optionEl.value = opt;
            optionEl.textContent = opt;
          }
          if (optionEl.value === selectedValue) optionEl.selected = true;
          select.append(optionEl);
      });
      select.addEventListener('change', changeHandler);
      return select;
  }
  
  function createNumericInputControl(label, stateKey, min, max, step) {
    const input = el('input', 'w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm');
    input.type = 'number';
    input.min = min;
    input.max = max;
    input.step = step;
    input.value = appState[stateKey];
    input.addEventListener('change', e => {
        const value = parseInt(e.target.value, 10);
        if (!isNaN(value) && value >= min && value <= max) {
            appState[stateKey] = value;
            debouncedSaveState();
        } else {
            e.target.value = appState[stateKey]; // Revert if invalid
        }
    });
    return createControlSection(label, input);
  }

  function createContextInput(placeholder, stateKey, className = '') {
    const input = el('input', `w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm ${className}`);
    input.placeholder = placeholder;
    input.value = appState[stateKey];
    input.addEventListener('input', e => { 
      appState[stateKey] = e.target.value.trim();
      resetSessionState("Advanced context changed, session reset.");
      updateControls();
      debouncedSaveState(); 
    });
    return input;
  }
  
  // --- State Management ---
  function saveState() {
    try {
        const stateToSave = { ...appState };
        // Don't save transient state
        ['isLoading', 'error', 'rawApiResponse', 'generationController'].forEach(key => delete stateToSave[key]);
        localStorage.setItem(`nameForgeState_v${APP_VERSION}`, JSON.stringify(stateToSave));
    } catch (e) { console.warn("Could not save state:", e); }
  }

  function loadState() {
      try {
        const saved = localStorage.getItem(`nameForgeState_v${APP_VERSION}`);
        if (saved) {
            const parsed = JSON.parse(saved);
            const defaults = { 
                version: APP_VERSION, 
                mode: 'forge', 
                harmonizerIsAllLanguages: false, 
                likedNames: [], 
                userLanguages: [], 
                userBlacklist: [], 
                gender: "Unisex", 
                outputAlphabet: "English (Default)", 
                model: "models/gemini-2.5-flash", 
                recentErrors: [], 
                hasSeenIntro: false,
                defaultCount: 6,
                apiTimeout: 60,
                maxOutputTokens: 1200,
                parallelMode: false,
            };
            Object.assign(appState, defaults, parsed);
        }
      } catch (e) { console.warn("Could not load state:", e); }
  }

  function resetSessionState(reason, preserveBlacklist = false) {
    const hasData = appState.likedNames.length > 0 || appState.sessionGeneratedNames.length > 0;
    
    appState.likedNames = [];
    if (!preserveBlacklist) appState.userBlacklist = [];
    appState.sessionGeneratedNames = [];

    if (hasData || reason.includes("Mode changed")) {
        showToast(reason);
        updateControls();
        appState.results = [];
        updateResultsPanel();
    }
  }

  // --- API & Data Processing ---
  /**
   * Parses the raw text response from the API.
   * It attempts multiple strategies to extract a valid JSON array,
   * handling cases where the response might be malformed or wrapped in markdown.
   */
  function parseApiResponse(text) {
    if (!text) return [];
    
    const arrayMatch = text.match(/\[[\s\S]*\]/);
    if (arrayMatch) {
        try {
            const parsed = JSON.parse(arrayMatch[0]);
            if (Array.isArray(parsed)) return parsed;
        } catch (e) {
            console.warn("Array extraction failed, trying cleanup:", e);
        }
    }
    
    let cleanedText = text.replace(/```[a-z]*\n?/gi, '').replace(/```/g, '').trim();
    try {
      const parsed = JSON.parse(cleanedText);
      if (Array.isArray(parsed)) return parsed;
      return [];
    } catch (e) { 
      console.warn("JSON parse completely failed. Raw response:", text);
      if (!appState.recentErrors) appState.recentErrors = [];
      appState.recentErrors.push(`${new Date().toLocaleTimeString()}: Failed to parse API response`);
      if (appState.recentErrors.length > 5) appState.recentErrors.shift();
      return []; 
    }
  }

  function processApiResponse(rawArray) {
    if (!rawArray?.length) return [];
    const fullBlacklist = appState.userBlacklist.map(b => b.toLowerCase());
    return rawArray.map(it => {
      let name = (it.name || "").toString().trim();
      if (!name || fullBlacklist.some(b => name.toLowerCase().includes(b))) return null;
      if (appState.outputAlphabet === 'English (Simplified/No Accents)') { 
        name = name.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      }
      const base = { name };
      if (appState.mode === 'forge') {
          return { ...base,
            meaning: (it.meaning || "").toString().trim(),
            roots: (it.roots || "").toString().trim(),
            cluster: (it.cluster || "Misc").trim(),
          };
      } else {
          return { ...base, 
            valid: it.valid === true,
            pronunciations: it.pronunciations || [], 
            semanticCheck: it.semanticCheck || "Pass" // Default to Pass if not provided
          };
      }
    }).filter(Boolean);
  }

  // --- UI Update & Rendering ---
  function updateResultsPanel() {
      ui.results.panel.innerHTML = '';
      if (appState.isLoading) {
          ui.results.panel.innerHTML = `
            <div class="flex flex-col items-center justify-center py-8 gap-4">
              <div class="spinner"></div>
              <div class="text-sm small-muted">Crafting ${appState.defaultCount} names...</div>
            </div>`;
      } else if (appState.error) {
          const escapedError = String(appState.error).replace(/</g, '&lt;');
          ui.results.panel.innerHTML = `<div class="bg-[#2b1a1a] border border-[#5b2626] rounded p-4"><div class="text-red-300 font-semibold">Error</div><div class="small-muted mt-2">${escapedError}</div></div>`;
      } else if (!appState.results.length) {
            if (appState.rawApiResponse) {
                // Fallback for when JSON parsing fails
                const escapedResponse = appState.rawApiResponse.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                ui.results.panel.innerHTML = `
                    <div class="flex flex-col gap-3 p-2">
                        <div class="font-semibold text-yellow-400">JSON Parsing Failed</div>
                        <div class="small-muted">The API returned a response, but it was not in the expected JSON format. Here is the raw text from the model:</div>
                        <pre class="w-full h-64 bg-[#0b1622] border border-[#223447] rounded p-2 text-xs font-mono overflow-auto">${escapedResponse}</pre>
                    </div>`;
            } else {
                 // Default empty state
                 ui.results.panel.innerHTML = '<div class="flex-1 flex items-center justify-center small-muted h-full">No names yet — click Generate.</div>';
            }
      } else {
          const grid = el('div','grid grid-cols-1 sm:grid-cols-2 gap-4 mt-2');
          if (appState.mode === 'forge') {
              const clusters = appState.results.reduce((acc, item) => ((acc[item.cluster] = acc[item.cluster] || []).push(item), acc), {});
              Object.keys(clusters).sort().forEach(clusterName => {
                  ui.results.panel.insertAdjacentHTML('beforeend', `<h3 class="text-md font-semibold text-blue-300 mt-4 first:mt-0">${clusterName}</h3>`);
                  const clusterGrid = el('div','grid grid-cols-1 sm:grid-cols-2 gap-4 mt-2');
                  clusters[clusterName].forEach(item => clusterGrid.append(createNameCard(item)));
                  ui.results.panel.append(clusterGrid);
              });
          } else {
              appState.results.forEach(item => grid.append(createNameCard(item)));
              ui.results.panel.append(grid);
          }
      }
  }
  
  function updateControls() {
    updateLanguageChips();
    if (appState.mode === 'forge') {
        updateChipSelector(ui.controls.themeChips, THEME_OPTIONS);
    }
    const riffText = appState.likedNames.length > 0 ? 'Riff on Liked' : 'Generate Names';
    const forgeText = appState.firstNameForMiddle ? 'Generate Middle Names' : riffText;
    ui.controls.generateButton.textContent = appState.mode === 'forge' ? forgeText : 'Generate Names';
    updateGenerateButtonState();
  }

  function updateGenerateButtonState() {
    const langRequirement = appState.selectedLanguages.length >= 2 && appState.selectedLanguages.length <= 3;
    const themeRequirement = appState.mode === 'forge' ? appState.selectedThemes.length >= 1 : true;
    const isReady = langRequirement && themeRequirement;
    if (ui.controls.generateButton) {
      ui.controls.generateButton.disabled = !isReady;
      ui.controls.generateButton.classList.toggle('opacity-50', !isReady);
      ui.controls.generateButton.classList.toggle('cursor-not-allowed', !isReady);
    }
  }

  function updateLanguageChips() {
    ui.controls.languageChips.innerHTML = '';
    const allLangs = [...new Set([...LANG_OPTIONS, ...appState.userLanguages])];
    
    appState.selectedLanguages.forEach(opt => {
        const c = el('button', 'chip active'); 
        c.dataset.option = opt;
        let content = opt;
        // Remove source indicator - simplified UX
        c.innerHTML = content;
        ui.controls.languageChips.append(c);
    });

    allLangs.filter(opt => !appState.selectedLanguages.includes(opt)).forEach(opt => {
        const c = el('button', 'chip'); 
        c.textContent = opt; 
        c.dataset.option = opt;
        ui.controls.languageChips.append(c);
    });
  }

  function updateChipSelector(container, options) {
      container.innerHTML = '';
      options.forEach(opt => {
          const c = el('button', 'chip'); c.textContent = opt; c.dataset.option = opt;
          if (appState[container.dataset.stateKey]?.includes(opt)) c.classList.add('active');
          container.append(c);
      });
  }
  
  function createNameCard(item) {
      const card = el('div',`bg-[#081426] border border-[#123047] rounded p-4 flex flex-col gap-2 fade`);
      card.dataset.nameCard = item.name;
      const header = el('div', 'flex items-start justify-between gap-2');
      header.innerHTML = `<div class="text-xl font-semibold">${item.name}</div>`;
      card.append(header);
      
      const isLiked = appState.likedNames.some(n => n.name === item.name);
      const isDisliked = appState.userBlacklist.includes(item.name.toLowerCase());
      
      if (appState.mode === 'forge') {
          const meaningEl = el('div', 'italic small-muted'); meaningEl.textContent = item.meaning || '—';
          const rootsEl = el('div', 'text-xs mt-auto pt-2 small-muted'); rootsEl.innerHTML = `<strong>Roots:</strong> ${item.roots || '—'}`;
          const actions = el('div', 'flex flex-wrap gap-2 mt-2');
          actions.innerHTML = `<button class="chip" data-action="copy-name" data-name="${item.name}">Copy</button><button class="chip thumb-btn ${isLiked ? 'active' : ''}" data-action="thumb-up" data-name="${item.name}">👍</button><button class="chip thumb-btn ${isDisliked ? 'active' : ''}" data-action="thumb-down" data-name="${item.name}">👎</button>`;
          card.append(meaningEl, rootsEl, actions);
      } else {
          const statusColor = item.valid ? 'text-green-400' : 'text-yellow-400';
          const validation = el('div', 'text-xs'); 
          validation.innerHTML = `<strong>Validation:</strong> <span class="${statusColor}">${item.valid ? 'Pass' : 'Approximate'}</span>`;
          if (item.semanticCheck !== 'Pass') {
            validation.innerHTML += `<br><strong>Semantic Note:</strong> <span class="text-yellow-400">${item.semanticCheck}</span>`;
          }
          const pronunciations = el('div', 'flex flex-col gap-1 mt-2 text-sm');
          item.pronunciations?.forEach(p => pronunciations.insertAdjacentHTML('beforeend', `<div><strong>${p.lang}:</strong> <span class="italic small-muted">/${p.phonetic}/</span></div>`));
          const actions = el('div', 'flex flex-wrap gap-2 mt-2');
          actions.innerHTML = `<button class="chip" data-action="copy-name" data-name="${item.name}">Copy</button>`;
          card.append(validation, pronunciations, actions);
      }
      return card;
  }

  // --- Event Handling ---
  function handleControlsClick(event) {
    const chip = event.target.closest('.chip[data-option]');
    if (chip) {
        const { option } = chip.dataset;
        const parentContainer = chip.parentElement;
        const stateKey = parentContainer.dataset.stateKey;
        if (!stateKey) return; 

        if (appState.mode === 'forge' && stateKey === 'selectedLanguages') {
            resetSessionState("Languages changed, session reset.");
        }
        
        const currentValue = appState[stateKey] || [];
        const max = stateKey === 'selectedLanguages' ? 3 : 2;

        if (currentValue.includes(option)) {
            appState[stateKey] = currentValue.filter(x => x !== option);
        } else {
            if (currentValue.length >= max) {
                appState[stateKey] = [...currentValue.slice(1), option];
            } else {
                appState[stateKey] = [...currentValue, option];
            }
        }
        
        debouncedSaveState();
        updateControls();
    }
  }

  function handleFeedback(name, isThumbUp) {
    const nameLower = name.toLowerCase();
    const isLiked = appState.likedNames.some(n => n.name === name);
    const isDisliked = appState.userBlacklist.includes(nameLower);

    if (isThumbUp) {
        if (isLiked) {
            appState.likedNames = appState.likedNames.filter(n => n.name !== name);
            showToast('Unliked!');
        } else {
            const nameObj = appState.results.find(r => r.name === name) || { name };
            if (nameObj) appState.likedNames.push(nameObj);
            if (isDisliked) appState.userBlacklist = appState.userBlacklist.filter(w => w !== nameLower);
            showToast('Liked!');
        }
    } else { // Thumb Down
        if (!isDisliked) {
            appState.userBlacklist.push(nameLower);
            if (isLiked) appState.likedNames = appState.likedNames.filter(n => n.name !== name);
            appState.results = appState.results.filter(item => item.name.toLowerCase() !== nameLower);
            updateResultsPanel();
            showToast('Blacklisted & removed!');
        }
    }

    debouncedSaveState();
    updateControls();
    const card = ui.results.panel.querySelector(`[data-name-card="${name}"]`);
    if (card) {
        const upBtn = card.querySelector('[data-action="thumb-up"]');
        const downBtn = card.querySelector('[data-action="thumb-down"]');
        if (upBtn) upBtn.classList.toggle('active', appState.likedNames.some(n => n.name === name));
        if (downBtn) downBtn.classList.toggle('active', appState.userBlacklist.includes(nameLower));
    }
  }
  
  function handleResultsPanelClick(event) {
      const btn = event.target.closest('button[data-action]');
      if (!btn) return;
      const { action, name } = btn.dataset;
      
      switch (action) {
        case 'copy-name':
          navigator.clipboard.writeText(name);
          showToast('Copied!');
          break;
        case 'thumb-up':
          handleFeedback(name, true);
          break;
        case 'thumb-down':
          handleFeedback(name, false);
          break;
      }
  }

  function createModal(id, title, contentEl, footerContent) {
    const modal = el('div', 'modal-backdrop items-center justify-center');
    modal.id = id;
    const content = el('div', 'modal-content bg-[#0e2030] border border-[#1b3146] rounded-lg p-6 flex flex-col gap-4 w-full max-w-lg');
    content.innerHTML = `<h3 class="text-lg font-semibold">${title}</h3>`;
    const scrollableContent = el('div', 'overflow-y-auto max-h-[60vh] pr-2 scrolling-panel');
    scrollableContent.append(contentEl);
    content.append(scrollableContent);
    if(footerContent) {
        const footer = el('div', 'flex gap-2 justify-end mt-2 pt-4 border-t border-gray-700/50');
        footer.append(...footerContent);
        content.append(footer);
    }
    modal.append(content);
    return modal;
  }
  
  function updateHistoryModal() {
    const historyContent = ui.modals.history.querySelector('.scrolling-panel');
    historyContent.innerHTML = '';

    if (appState.likedNames.length > 0) {
        const likedSection = el('div');
        likedSection.innerHTML = `<h4 class="text-sm font-semibold text-green-400 mb-2">👍 Liked Names (${appState.likedNames.length})</h4>`;
        const likedList = el('div', 'space-y-2');
        appState.likedNames.forEach(nameObj => {
            const item = el('div', 'bg-[#0a1a2e] rounded p-2 text-sm');
            item.innerHTML = `<div class="font-medium">${nameObj.name}</div>`;
            if (nameObj.meaning) item.innerHTML += `<div class="text-xs small-muted italic mt-1">${nameObj.meaning}</div>`;
            if (nameObj.roots) item.innerHTML += `<div class="text-xs small-muted mt-1"><strong>Roots:</strong> ${nameObj.roots}</div>`;
            likedList.append(item);
        });
        likedSection.append(likedList);
        historyContent.append(likedSection);
    }

    if (appState.userBlacklist.length > 0) {
        const blacklistSection = el('div', 'mt-4');
        blacklistSection.innerHTML = `<h4 class="text-sm font-semibold text-red-400 mb-2">👎 Blacklisted Words (${appState.userBlacklist.length})</h4>`;
        const blacklistList = el('div', 'flex flex-wrap gap-2');
        appState.userBlacklist.forEach(word => {
            const chip = el('span', 'chip bg-red-900/30 text-red-300 text-xs');
            chip.textContent = word;
            blacklistList.append(chip);
        });
        blacklistSection.append(blacklistList);
        historyContent.append(blacklistSection);
    }

    if (appState.sessionGeneratedNames.length > 0) {
        const sessionSection = el('div', 'mt-4');
        sessionSection.innerHTML = `<h4 class="text-sm font-semibold text-gray-400 mb-2">🧠 Session Memory (showing last 20 of ${appState.sessionGeneratedNames.length})</h4>`;
        const sessionNote = el('div', 'text-xs small-muted mb-2');
        sessionNote.textContent = 'Names avoided this session to prevent repetition:';
        const sessionList = el('div', 'flex flex-wrap gap-1');
        appState.sessionGeneratedNames.slice(-20).reverse().forEach(name => {
            const chip = el('span', 'text-xs px-2 py-1 bg-gray-800 text-gray-400 rounded');
            chip.textContent = name;
            sessionList.append(chip);
        });
        sessionSection.append(sessionNote, sessionList);
        historyContent.append(sessionSection);
    }

    if (appState.recentErrors && appState.recentErrors.length > 0) {
        const errorsSection = el('div', 'mt-4');
        errorsSection.innerHTML = `<h4 class="text-sm font-semibold text-yellow-400 mb-2">⚠️ Recent Errors</h4>`;
        const errorsList = el('div', 'space-y-1');
        appState.recentErrors.slice(-3).forEach(error => {
            const item = el('div', 'bg-red-900/20 rounded p-2 text-xs text-red-300');
            item.textContent = error;
            errorsList.append(item);
        });
        errorsSection.append(errorsList);
        historyContent.append(errorsSection);
    }

    if (!appState.likedNames.length && !appState.userBlacklist.length && !appState.sessionGeneratedNames.length) {
        historyContent.innerHTML = '<div class="text-center small-muted py-8">No session data yet. Generate some names to see feedback history!</div>';
    }
  }

  // --- UI Creation Functions ---
  function createHeader() {
    const header = el('div', 'flex justify-between items-center');
    const titleDiv = el('div');
    titleDiv.innerHTML = `<h1 class="text-xl font-semibold">NameForge</h1><div class="small-muted mt-1">Craft a name with meaning</div>`;
    const buttonsDiv = el('div', 'flex items-center gap-2');
    
    const viewPromptBtn = el('button', 'chip');
    viewPromptBtn.textContent = 'View Prompt';
    viewPromptBtn.addEventListener('click', () => {
        const prompt = buildApiPrompt();
        const promptContent = ui.modals.prompt.querySelector('textarea');
        promptContent.value = prompt;
        toggleModal(ui.modals.prompt, true);
    });

    const historyBtn = el('button', 'chip');
    historyBtn.textContent = 'History';
    historyBtn.addEventListener('click', () => { updateHistoryModal(); toggleModal(ui.modals.history, true); });

    const settingsBtn = el('button', 'chip');
    settingsBtn.textContent = 'Settings';
    settingsBtn.addEventListener('click', () => toggleModal(ui.modals.settings, true));
    
    buttonsDiv.append(viewPromptBtn, historyBtn, settingsBtn);
    header.append(titleDiv, buttonsDiv);
    return header;
  }

  function createControlsPanel() {
    const left = el('div','md:col-span-1 bg-[#071425] border border-[#0e2334] rounded-xl p-5 flex flex-col gap-4 h-fit');
    left.append(createHeader());

    const modeSwitcher = el('div', 'mode-toggle mt-4');
    modeSwitcher.innerHTML = `<button data-mode="forge" class="${appState.mode === 'forge' ? 'active' : ''}">Forge</button><button data-mode="harmonizer" class="${appState.mode === 'harmonizer' ? 'active' : ''}">Harmonizer</button>`;
    left.append(modeSwitcher);
    
    const controlsContainer = el('div', 'flex flex-col gap-4 mt-4');
    
    const coreQuerySection = el('details', 'border border-[#0e2334] rounded-lg');
    coreQuerySection.open = true;
    const coreQuerySummary = el('summary', 'text-md font-semibold p-3 cursor-pointer list-none');
    coreQuerySummary.innerHTML = `Step 1: Define Core Query <span class="small-muted font-normal">(Languages & Context)</span>`;
    coreQuerySection.append(coreQuerySummary);
    
    const coreQueryContent = el('div', 'p-3 border-t border-[#0e2334] flex flex-col gap-4');
    const languagesSection = createControlSection('Languages (choose 2-3)', el('div'));
    ui.controls.languageChips = el('div', 'flex flex-wrap gap-2');
    ui.controls.languageChips.dataset.stateKey = 'selectedLanguages';
    const addLangWrap = el('div', 'flex gap-2 mt-2');
    const langInput = el('input', 'w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm');
    langInput.placeholder = 'Add a language...';
    const addLangBtn = el('button', 'bg-[#0e2436] border border-[#1b3146] px-3 py-2 rounded text-sm small-muted');
    addLangBtn.textContent = 'Add';
    addLangBtn.addEventListener('click', () => {
        const newLang = langInput.value.trim();
        if (newLang.length < 2) return;
        if (newLang && ![...LANG_OPTIONS, ...appState.userLanguages].map(l=>l.toLowerCase()).includes(newLang.toLowerCase())) {
            appState.userLanguages.push(newLang);
            if(appState.selectedLanguages.length < 3) appState.selectedLanguages.push(newLang);
            debouncedSaveState(); updateControls();
        }
        langInput.value = '';
    });
    addLangWrap.append(langInput, addLangBtn);
    languagesSection.append(ui.controls.languageChips, addLangWrap);
    
    ui.controls.advancedSection = createControlSection('Advanced Context', el('div', 'grid grid-cols-2 gap-4'));
    const advancedGrid = ui.controls.advancedSection.querySelector('div');
    advancedGrid.append(
        createContextInput("Surname", "surname"),
        createContextInput("Sibling Names", "siblingNames"),
        createContextInput("First Name (for middle)", "firstNameForMiddle", "col-span-2")
    );
    coreQueryContent.append(languagesSection, ui.controls.advancedSection);
    coreQuerySection.append(coreQueryContent);
    controlsContainer.append(coreQuerySection);

    const flavorSection = el('div', 'flex flex-col gap-4 mt-4');
    const flavorHeader = el('div', 'text-md font-semibold');
    flavorHeader.innerHTML = `Step 2: Refine Flavor <span class="small-muted font-normal">(Style, Themes, etc.)</span>`;
    flavorSection.append(flavorHeader);
    
    ui.controls.forgeContainer = el('div', 'flex flex-col gap-4');
    ui.controls.harmonizerContainer = el('div', 'flex flex-col gap-4');

    ui.controls.harmonizerToggleSection = el('div');
    ui.controls.harmonizerToggleSection.innerHTML = `<div class="toggle-switch"><span class="text-sm font-medium">Proper noun in all selected languages</span><input type="checkbox" class="toggle-switch-input" id="harmonizer-toggle"><label class="toggle-switch-label" for="harmonizer-toggle">Toggle</label></div>`;
    ui.controls.harmonizerContainer.append(ui.controls.harmonizerToggleSection);

    ui.controls.themesSection = createControlSection('Themes (choose 1–2)', el('div', 'flex flex-wrap gap-2'));
    ui.controls.themeChips = ui.controls.themesSection.querySelector('div'); 
    ui.controls.themeChips.dataset.stateKey = 'selectedThemes';
    ui.controls.styleSection = createControlSection('Style', createSelectControl(STYLE_OPTIONS, appState.selectedStyle, e => { appState.selectedStyle = e.target.value; debouncedSaveState(); }));
    ui.controls.forgeContainer.append(ui.controls.themesSection, ui.controls.styleSection);
    
    flavorSection.append(ui.controls.forgeContainer, ui.controls.harmonizerContainer);
    flavorSection.append(createControlSection('Gender', createSelectControl(["Unisex", "Male", "Female"], appState.gender, e => { appState.gender = e.target.value; debouncedSaveState(); })));
    controlsContainer.append(flavorSection);
    
    left.append(controlsContainer);

    return { left, modeSwitcher };
  }

  function createResultsPanel() {
    const right = el('div','md:col-span-2 bg-[#071427] border border-[#0e2030] rounded-xl p-5 flex flex-col gap-2');
    
    ui.controls.generateButton = el('button','bg-gradient-to-r from-[#3b82f6] to-[#2563eb] text-white px-4 py-3 rounded font-semibold shadow w-full');
    right.append(ui.controls.generateButton);

    ui.results.header = el('div');
    right.append(ui.results.header);

    ui.results.panel = el('div','mt-2 p-3 bg-[#071a25] border border-[#0f2a3a] rounded-lg min-h-[280px] flex flex-col');
    right.append(ui.results.panel);
    return right;
  }
  
  function initLayout() {
    ui.root.innerHTML = '';
    const appWrap = el('div','max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-3 gap-6');
    
    const { left, modeSwitcher } = createControlsPanel();
    const right = createResultsPanel();
    
    appWrap.append(left, right);
    ui.root.append(appWrap);
    
    // --- Modals ---
    // Settings Modal
    const settingsContent = el('div', 'flex flex-col gap-4');
    const apiKeyInput = el('input', 'w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm');
    apiKeyInput.type = 'password';
    apiKeyInput.placeholder = 'Enter your Gemini API key';
    apiKeyInput.value = appState.apiKey;
    apiKeyInput.addEventListener('input', e => { appState.apiKey = e.target.value.trim(); debouncedSaveState(); });
    const modelSel = createSelectControl(MODEL_OPTIONS, appState.model, e => { appState.model = e.target.value; debouncedSaveState(); });
    const alphabetOptions = ['English (Default)', 'English (Simplified/No Accents)'];
    const alphabetSel = createSelectControl(alphabetOptions, appState.outputAlphabet, e => { appState.outputAlphabet = e.target.value; debouncedSaveState(); });
    settingsContent.append(
        createControlSection('Gemini API Key', apiKeyInput),
        createControlSection('Model', modelSel),
        createControlSection('Output Character Set', alphabetSel),
        createNumericInputControl('Names Per Generation', 'defaultCount', 4, 20, 1),
        createNumericInputControl('API Timeout (seconds)', 'apiTimeout', 10, 120, 5),
        createNumericInputControl('Max Response Length (tokens)', 'maxOutputTokens', 800, 4000, 100)
    );
    const parallelToggle = el('div', 'toggle-switch');
    parallelToggle.innerHTML = `
        <span class="text-sm font-medium">Parallel Generation (2x faster, uses 2x quota)</span>
        <input type="checkbox" class="toggle-switch-input" id="parallel-toggle" ${appState.parallelMode ? 'checked' : ''}>
        <label class="toggle-switch-label" for="parallel-toggle">Toggle</label>
    `;
    parallelToggle.querySelector('input').addEventListener('change', e => {
        appState.parallelMode = e.target.checked;
        debouncedSaveState();
    });
    settingsContent.append(parallelToggle);
    const settingsCloseBtn = el('button', 'chip bg-blue-800/50 justify-center');
    settingsCloseBtn.textContent = 'Close';
    settingsCloseBtn.addEventListener('click', () => toggleModal(ui.modals.settings, false));
    ui.modals.settings = createModal('settings-modal', 'Settings', settingsContent, [settingsCloseBtn]);
    
    // History Modal
    const historyContent = el('div', 'space-y-4');
    const historyCloseBtn = el('button', 'chip bg-blue-800/50 justify-center');
    historyCloseBtn.textContent = 'Close';
    historyCloseBtn.addEventListener('click', () => toggleModal(ui.modals.history, false));
    ui.modals.history = createModal('history-modal', 'Session Feedback', historyContent, [historyCloseBtn]);

    // Prompt Modal
    const promptContent = el('div', 'flex flex-col gap-2');
    promptContent.innerHTML = `<textarea readonly class="w-full h-64 bg-[#0b1622] border border-[#223447] rounded p-2 text-xs font-mono"></textarea>`;
    const copyPromptBtn = el('button', 'chip self-start bg-blue-800/50');
    copyPromptBtn.textContent = 'Copy Prompt';
    copyPromptBtn.addEventListener('click', () => {
        const promptText = ui.modals.prompt.querySelector('textarea').value;
        navigator.clipboard.writeText(promptText);
        showToast('Prompt copied!');
    });
    const promptCloseBtn = el('button', 'chip');
    promptCloseBtn.textContent = 'Close';
    promptCloseBtn.addEventListener('click', () => toggleModal(ui.modals.prompt, false));
    ui.modals.prompt = createModal('prompt-modal', 'Current API Prompt', promptContent, [promptCloseBtn, copyPromptBtn]);

    // Welcome Modal
    const welcomeContent = el('div', 'flex flex-col gap-3 text-sm small-muted');
    welcomeContent.innerHTML = `
      <p>Welcome to NameForge! This app helps you create unique names by blending languages and themes.</p>
      <div class="p-3 bg-black/20 rounded-md">
        <strong class="text-base text-gray-200">How it works:</strong>
        <ul class="list-disc list-inside mt-2 space-y-1">
            <li><strong>Forge Mode:</strong> Creates new, poetic names from language roots and themes.</li>
            <li><strong>Harmonizer Mode:</strong> Finds existing names that work across multiple cultures.</li>
        </ul>
      </div>
      <p>To generate names, the app uses the Google Gemini API. You'll need a free API key to get started.</p>
    `;
    const welcomeApiKeyInput = el('input', 'w-full bg-[#0b1622] border border-[#223447] rounded px-3 py-2 text-sm');
    welcomeApiKeyInput.placeholder = 'Paste your Gemini API key here';
    welcomeApiKeyInput.value = appState.apiKey;
    const getApiKeyLink = el('a', 'text-blue-400 hover:underline text-xs');
    getApiKeyLink.href = 'https://ai.google.dev/gemini-api/docs/api-key';
    getApiKeyLink.target = '_blank';
    getApiKeyLink.textContent = 'How to get an API Key →';
    const welcomeApiSection = createControlSection('Enter your Gemini API Key', welcomeApiKeyInput);
    welcomeApiSection.append(getApiKeyLink);
    welcomeContent.append(welcomeApiSection);

    const saveKeyBtn = el('button', 'chip bg-blue-700 text-white font-semibold flex-1 justify-center');
    saveKeyBtn.textContent = 'Save & Start';
    saveKeyBtn.addEventListener('click', () => {
        const key = welcomeApiKeyInput.value.trim();
        if (key) {
            appState.apiKey = key;
            appState.hasSeenIntro = true;
            debouncedSaveState();
            toggleModal(ui.modals.welcome, false);
            showToast('API Key saved!');
        } else {
            showToast('Please enter an API key.', true);
        }
    });

    const noKeyBtn = el('button', 'chip flex-1 justify-center');
    noKeyBtn.textContent = 'Use without API for now';
    noKeyBtn.addEventListener('click', () => {
        appState.hasSeenIntro = true;
        debouncedSaveState();
        toggleModal(ui.modals.welcome, false);
        showToast('You can add an API key later in Settings.');
    });
    ui.modals.welcome = createModal('welcome-modal', 'Welcome to NameForge', welcomeContent, [noKeyBtn, saveKeyBtn]);
    
    ui.root.append(ui.modals.settings, ui.modals.history, ui.modals.prompt, ui.modals.welcome);

    // --- Event Listeners & Initial UI State ---
    const toggleModeUI = (mode) => {
        const isForge = mode === 'forge';
        ui.controls.forgeContainer.style.display = isForge ? 'flex' : 'none';
        ui.controls.advancedSection.style.display = isForge ? 'block' : 'none';
        ui.controls.harmonizerContainer.style.display = isForge ? 'none' : 'flex';
        ui.controls.themesSection.style.display = isForge ? 'block' : 'none';
        resetSessionState("Mode changed, session reset.", true);
        ui.results.header.innerHTML = `<div><h2 class="text-lg font-semibold">${isForge ? 'Results' : 'Harmonized Names'}</h2><div class="small-muted">${isForge ? 'Poetic, culturally coined names' : 'Names that work across cultures'}</div></div>`;
        appState.results = []; updateResultsPanel(); updateControls();
    };
    
    toggleModeUI(appState.mode);
    ui.controls.harmonizerToggleSection.querySelector('input').checked = appState.harmonizerIsAllLanguages;

    modeSwitcher.addEventListener('click', (e) => {
        const button = e.target.closest('button[data-mode]');
        if (button && appState.mode !== button.dataset.mode) {
            appState.mode = button.dataset.mode;
            modeSwitcher.querySelector('.active').classList.remove('active');
            button.classList.add('active');
            debouncedSaveState(); toggleModeUI(appState.mode);
        }
    });

    ui.controls.harmonizerToggleSection.querySelector('input').addEventListener('change', (e) => {
        appState.harmonizerIsAllLanguages = e.target.checked;
        updateLanguageChips();
        debouncedSaveState();
    });
    
    left.addEventListener('click', handleControlsClick);
    right.addEventListener('click', handleResultsPanelClick);
    ui.controls.generateButton.addEventListener('click', () => doGenerate());
  }

  // --- Prompt Building ---
  function buildApiPrompt(countOverride) {
      const count = countOverride || appState.defaultCount;
      if (appState.mode === 'forge') {
          return buildForgePrompt(count);
      } else {
          return buildHarmonizerPrompt(count);
      }
  }

  function buildForgePrompt(count) {
    const { selectedLanguages, likedNames, selectedThemes, selectedStyle, gender, userBlacklist } = appState;
    const inspirational = likedNames.length > 0 ? likedNames.map(n => n.name).join(', ') : 'none';
    const blacklisted = userBlacklist.length > 0 ? userBlacklist.join(', ') : 'none';

    let taskLines = [`Generate ${count} original ${gender} names.`];
    taskLines.push(`Languages: ${selectedLanguages.join(' + ')}`);
    if (selectedThemes.length > 0) taskLines.push(`Themes: ${selectedThemes.join(', ')}`);
    taskLines.push(`Style: ${selectedStyle}`);
    const task = taskLines.join('\n');

    return `
You are a poet-linguist forging names.

== CRITICAL RULES ==
1. Multi-language fusion: Each name must use 2–3 morphemes from different TASK languages. No single-language names.
2. Roots fidelity: "roots" lists every morpheme with language + gloss. If invented, mark (coined). If gloss uncertain, mark (approx).
3. Cluster: Must equal exactly one of: ["Lyrical & Melodic","Archaic & Mythic","Minimalist & Modern","Heroic & Resonant","Elegant & Refined","Grounded & Earthy","Mystical & Ethereal"].
4. Output format: Return ONLY a valid JSON array of objects. No other text or explanation.

== SCHEMA EXAMPLE ==
[
  {
    "name": "Astroren",
    "roots": "astro (Greek: star) + ren (Nordic: raven)",
    "meaning": "Celestial raven of wisdom",
    "cluster": "Heroic & Resonant"
  }
]

== PRINCIPLES ==
- Meaning = poetic interpretation of theme.
- Roots = factual morpheme breakdown.

== SESSION CONTEXT ==
Inspirational 👍: ${inspirational}
Blacklisted 👎: ${blacklisted}

== TASK ==
${task}
`;
  }
  
  function buildHarmonizerPrompt(count) {
      const { selectedLanguages, gender } = appState;

      return `
You are a cross-cultural linguistic analyst.

== PRIMARY DIRECTIVE ==
Validate human names for cross-cultural compatibility. Names should be recognized or easily adapted as proper names in ALL TASK languages.

== CORE CHECKS ==
1. Phonetic compatibility: Note if any phoneme is approximate across languages. Mark with (approx) instead of rejecting.
2. Semantic safety: Flag if the name is also a common object/place/negative concept. Do not reject; just mark it.

== OUTPUT FORMAT (JSON only) ==
Return ONLY a valid JSON array of objects. No other text or explanation.

== SCHEMA EXAMPLE ==
[
  {
    "name": "Arda",
    "valid": true,
    "pronunciations": [
      {"lang": "Turkish", "phonetic": "AR-dah"},
      {"lang": "Nordic", "phonetic": "AHR-da (approx)"}
    ],
    "semanticCheck": "Pass"
  }
]

== TASK ==
Generate ${count} ${gender} names.
Languages: ${selectedLanguages.join(' + ')}
Name form: 4–10 letters, 2–3 syllables.
Style: ${gender}
`;
  }

    async function doGenerate() {
        if (appState.isLoading) return;
        updateGenerateButtonState();
        if (ui.controls.generateButton.disabled) {
            showToast("Please select 2-3 languages and (in Forge mode) at least 1 theme.", true);
            return;
        }
        
        const key = appState.apiKey.trim();
        if (!key) {
            const prompt = buildApiPrompt();
            ui.results.panel.innerHTML = `
                <div class="flex flex-col gap-3 p-2">
                    <div class="small-muted">API Key is missing. Copy the prompt below to use in your preferred LLM tool, or add your key in the Settings modal.</div>
                    <textarea readonly class="w-full h-64 bg-[#0b1622] border border-[#223447] rounded p-2 text-xs font-mono">${prompt}</textarea>
                    <button id="copy-prompt-btn" class="chip self-start bg-blue-800/50">Copy Prompt</button>
                </div>`;
            document.getElementById('copy-prompt-btn').addEventListener('click', () => {
                navigator.clipboard.writeText(prompt);
                showToast('Prompt copied!');
            });
            return;
        }

        appState.error = null;
        appState.results = [];
        appState.rawApiResponse = null;
        appState.isLoading = true;
        appState.generationController = new AbortController();
        updateResultsPanel();

        const timeoutId = setTimeout(() => {
            if(appState.generationController) appState.generationController.abort()
        }, appState.apiTimeout * 1000);

        try {
            let allResults = [];
            
            if (appState.parallelMode && appState.defaultCount >= 4) {
                // Parallel mode: split into two batches
                const halfCount = Math.ceil(appState.defaultCount / 2);
                
                const prompt1 = buildApiPrompt(halfCount);
                const prompt2 = buildApiPrompt(halfCount);
                
                const [result1, result2] = await Promise.all([
                    callGeminiAPI(prompt1, key, appState.generationController.signal),
                    callGeminiAPI(prompt2, key, appState.generationController.signal)
                ]);
                
                allResults = [...result1, ...result2];
            } else {
                // Standard mode: single request
                const prompt = buildApiPrompt();
                allResults = await callGeminiAPI(prompt, key, appState.generationController.signal);
            }

            if (allResults.length) {
                appState.sessionGeneratedNames.push(...allResults.map(p => p.name));
                appState.results = allResults.slice(0, appState.defaultCount); // Ensure we don't exceed the requested count
            }
            // If allResults is empty, the fallback in updateResultsPanel will handle it

        } catch (error) {
            let errorMsg;
            if (error.name === 'AbortError') {
                errorMsg = "Generation timed out or was cancelled by user.";
            } else {
                errorMsg = error.message || String(error);
            }
            if (errorMsg.includes('quota') || errorMsg.includes('limit')) {
                errorMsg += ' Try switching to a different model in Settings.';
            }
            if (errorMsg.includes('safety') || errorMsg.includes('blocked')) {
                errorMsg += ' Try adjusting your language/theme selections.';
            }
            appState.error = errorMsg;
            
            if (!appState.recentErrors) appState.recentErrors = [];
            appState.recentErrors.push(`${new Date().toLocaleTimeString()}: ${errorMsg}`);
            if (appState.recentErrors.length > 5) appState.recentErrors.shift();
        } finally {
            clearTimeout(timeoutId);
            appState.isLoading = false;
            appState.generationController = null;
            updateResultsPanel();
            debouncedSaveState();
        }
    }

    // Helper function for API calls
    async function callGeminiAPI(prompt, key, signal) {
        const body = { 
            contents: [{ parts: [{ text: prompt }] }], 
            generationConfig: { 
                temperature: 0.8, 
                topP: 0.9, 
                maxOutputTokens: appState.maxOutputTokens
            } 
        };

        const response = await fetch(
            `${API_BASE_URL}${appState.model}:generateContent?key=${encodeURIComponent(key)}`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
                signal: signal
            }
        );

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API error ${response.status}: ${errorText}`);
        }

        const data = await response.json();
        const rawResponse = data?.candidates?.[0]?.content?.parts?.[0]?.text || "";
        appState.rawApiResponse = rawResponse;

        const parsed = parseApiResponse(rawResponse);
        return processApiResponse(parsed);
    }

  window.addEventListener('beforeunload', () => {
      if (appState.generationController) {
          appState.generationController.abort();
      }
  });

  loadState();
  initLayout();
  updateControls();
  updateResultsPanel();
  
  if (!appState.hasSeenIntro) {
    toggleModal(ui.modals.welcome, true);
  }
})();
  </script>
</body>
</html>

